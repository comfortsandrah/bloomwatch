<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GLOBE Temps Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .legend { background: white; padding: 10px; line-height: 1.2; font: 12px/1.2 Arial; }
    .legend .scale { display: flex; align-items: center; }
    .legend .bar { height: 12px; flex: 1; background: linear-gradient(to right, #2166ac, #67a9cf, #d1e5f0, #fddbc7, #ef8a62, #b2182b); margin: 0 8px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <!-- Leaflet.heat plugin for continuous gradient surface -->
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script>
    // Default bounds for color scale; will be replaced by dataset min/max after load
    let TEMP_MIN = 0;   // cold
    let TEMP_MAX = 45;  // hot

    function lerp(a, b, t) { return a + (b - a) * t; }
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    // Convert temp to color from blue (cold) to red (hot) using a 3-stop gradient
    function tempToColor(tempC) {
      const t = clamp((tempC - TEMP_MIN) / (TEMP_MAX - TEMP_MIN), 0, 1);
      // Gradient from blue (#2166ac) -> light (#fddbc7) -> red (#b2182b)
      const stops = [
        { r: 0x21, g: 0x66, b: 0xac },
        { r: 0xfd, g: 0xdb, b: 0xc7 },
        { r: 0xb2, g: 0x18, b: 0x2b }
      ];
      const seg = t * (stops.length - 1);
      const i = Math.floor(seg);
      const f = seg - i;
      const a = stops[i];
      const b = stops[Math.min(i + 1, stops.length - 1)];
      const r = Math.round(lerp(a.r, b.r, f));
      const g = Math.round(lerp(a.g, b.g, f));
      const bch = Math.round(lerp(a.b, b.b, f));
      return `rgb(${r}, ${g}, ${bch})`;
    }

  const map = L.map('map').setView([20, 0], 2); // Generic view; we'll fit to data

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function() {
      const div = L.DomUtil.create('div', 'legend');
      div.innerHTML = `
        <div><strong>Temperature (°C)</strong></div>
        <div class="scale"><span id="legend-min">${TEMP_MIN}</span><div class="bar"></div><span id="legend-max">${TEMP_MAX}</span></div>
      `;
      return div;
    };
    legend.addTo(map);

    // Build query params (defaults target Kenya last 365 days, air temps only)
    const url = new URL(window.location.origin + '/api/data');
    const params = new URLSearchParams(window.location.search);
    const protocols = params.getAll('protocols');
    const country = params.get('country') || 'KEN';
    const startdate = params.get('startdate');
    const enddate = params.get('enddate');

    if (protocols.length === 0) url.searchParams.append('protocols', 'air_temps');
    else protocols.forEach(p => url.searchParams.append('protocols', p));
    url.searchParams.set('country', country);
    if (startdate) url.searchParams.set('startdate', startdate);
    if (enddate) url.searchParams.set('enddate', enddate);
    url.searchParams.set('size', '500');

    fetch(url.toString())
      .then(r => r.json())
      .then(data => {
        if (!data || !Array.isArray(data.results)) {
          console.warn('No results', data);
          alert('No results for the selected filters. Try widening the date range.');
          return;
        }

        // Prepare containers
        const markers = L.layerGroup();
        const latLngs = [];
        const points = []; // {lat, lng, temp}
        let minT = Infinity, maxT = -Infinity;

        // Collect points and draw markers
        data.results.forEach(item => {
          if (item.protocol !== 'air_temps') return; // focus on air temps for coloring
          if (typeof item.latitude !== 'number' || typeof item.longitude !== 'number') return;
          const d = item.data || {};
          const temp = d.airtempsCurrentTemp;
          if (typeof temp !== 'number') return;

          points.push({ lat: item.latitude, lng: item.longitude, temp });
          minT = Math.min(minT, temp);
          maxT = Math.max(maxT, temp);
          latLngs.push([item.latitude, item.longitude]);

          const color = tempToColor(temp);
          const marker = L.circleMarker([item.latitude, item.longitude], {
            radius: 6,
            color: color,
            fillColor: color,
            fillOpacity: 0.8,
            weight: 1
          });

          const when = item.measuredDate || '';
          const site = item.siteName || '';
          const org = item.organizationName || '';
          marker.bindPopup(`
            <div><strong>${site}</strong></div>
            <div>${org}</div>
            <div>${when}</div>
            <div><strong>${temp} °C</strong></div>
          `);
          markers.addLayer(marker);
        });

        if (points.length === 0) {
          alert('No temperature points found in the data.');
          return;
        }

        // Update dynamic color scale based on dataset
        TEMP_MIN = minT;
        TEMP_MAX = maxT;
        const minEl = document.getElementById('legend-min');
        const maxEl = document.getElementById('legend-max');
        if (minEl) minEl.textContent = TEMP_MIN.toFixed(1);
        if (maxEl) maxEl.textContent = TEMP_MAX.toFixed(1);

        // Create heatmap points: [lat, lng, intensity]
        const heatPoints = points.map(p => [p.lat, p.lng, clamp((p.temp - TEMP_MIN) / (TEMP_MAX - TEMP_MIN || 1), 0, 1)]);

        // Blue→red gradient
        const heatGradient = {
          0.0: '#2166ac', // blue
          0.5: '#fddbc7', // light
          1.0: '#b2182b'  // red
        };

        const heat = L.heatLayer(heatPoints, {
          radius: 25,
          blur: 15,
          maxZoom: 12,
          gradient: heatGradient
        }).addTo(map);

        // Add markers overlay and layer control
        markers.addTo(map);
        L.control.layers({}, { 'Heatmap': heat, 'Markers': markers }, { collapsed: false }).addTo(map);

        // Fit to data
        try {
          const bounds = L.latLngBounds(latLngs);
          if (bounds.isValid()) map.fitBounds(bounds, { padding: [20, 20] });
        } catch (e) { /* ignore */ }
      })
      .catch(err => {
        console.error(err);
        alert('Failed to load data. Check console.');
      });
  </script>
</body>
</html>
