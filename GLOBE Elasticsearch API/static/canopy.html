<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Canopy Cover Heatmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .panel { position: absolute; z-index: 1000; top: 10px; left: 10px; background: #fff; padding: 8px 10px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font: 13px Arial; }
    .legend { position: absolute; z-index: 1000; bottom: 10px; right: 10px; background: #fff; padding: 8px 10px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font: 12px Arial; }
    .legend .bar { height: 12px; width: 240px; background: linear-gradient(to right, #2166ac, #67a9cf, #d1e5f0, #fddbc7, #ef8a62, #b2182b); margin: 6px 0; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="panel">
    <label>Min canopy (0-1 or %): <input id="minCan" type="text" value="0.1" size="6" /></label>
    <button id="apply">Apply</button>
  </div>
  <div class="legend">
    <div><strong>Canopy Cover (%)</strong></div>
    <div class="bar"></div>
    <div><span id="minv">0</span> â€“ <span id="maxv">100</span></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script>
    const map = L.map('map').setView([39.8283, -98.5795], 4); // USA center
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18, attribution: '&copy; OpenStreetMap' }).addTo(map);

    // URL params
    const params = new URLSearchParams(window.location.search);
    const urlMinCan = params.get('minCanopy');
    const initialMin = urlMinCan || '0.1';
    document.getElementById('minCan').value = initialMin;

    let TEMP_MIN = Infinity, TEMP_MAX = -Infinity; // Percent scale bounds (will update from data)

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // Dynamic radius by zoom for coverage
    function rad(z) { return Math.max(12, Math.round(90 - 5*z)); }

    function makeColor(val, minV, maxV) {
      const t = clamp((val - minV) / (maxV - minV || 1), 0, 1);
      // 3-stop scale blue -> light -> red
      const s = [
        { r:0x21,g:0x66,b:0xac },
        { r:0xfd,g:0xdb,b:0xc7 },
        { r:0xb2,g:0x18,b:0x2b }
      ];
      const seg = t*(s.length-1); const i = Math.floor(seg), f = seg - i;
      const a = s[i], b = s[Math.min(i+1, s.length-1)];
      const R = Math.round(a.r + (b.r-a.r)*f);
      const G = Math.round(a.g + (b.g-a.g)*f);
      const B = Math.round(a.b + (b.b-a.b)*f);
      return `rgb(${R},${G},${B})`;
    }

    let heat, markers;

    function loadData() {
      const minCan = document.getElementById('minCan').value.trim();
      const q = new URLSearchParams();
      if (minCan) q.set('minCanopy', minCan);
      q.set('limit', '20000');

      fetch(`/api/csv/canopy?${q.toString()}`)
        .then(r => r.json())
        .then(payload => {
          const rows = payload.results || [];
          if (!rows.length) {
            alert('No rows found for the given filter.');
            return;
          }

          // Clear existing layers
          if (heat) map.removeLayer(heat);
          if (markers) map.removeLayer(markers);

          TEMP_MIN = Math.min(...rows.map(r => r.canopy));
          TEMP_MAX = Math.max(...rows.map(r => r.canopy));
          document.getElementById('minv').textContent = TEMP_MIN.toFixed(1);
          document.getElementById('maxv').textContent = TEMP_MAX.toFixed(1);

          // Build heat points with high contrast: split cold vs hot
          const pts = rows.map(r => {
            const v = r.canopy; // percent 0-100
            return { lat: r.lat, lon: r.lon, v };
          });

          // Normalize to intensity
          const gamma = parseFloat(params.get('gamma') || '0.6');
          const floor = parseFloat(params.get('floor') || '0.3');

          const cold = [], hot = [], ll = [];
          pts.forEach(p => {
            let n = clamp((p.v - TEMP_MIN) / (TEMP_MAX - TEMP_MIN || 1), 0, 1);
            n = Math.pow(n, gamma);
            const hotI = clamp(floor + (1-floor)*n, 0, 1);
            const coldI = clamp(floor + (1-floor)*(1-n), 0, 1);
            hot.push([p.lat, p.lon, hotI]);
            cold.push([p.lat, p.lon, coldI]);
            ll.push([p.lat, p.lon]);
          });

          const r = rad(map.getZoom());
          const blur = parseFloat(params.get('blur') || '35');

          const coldLayer = L.heatLayer(cold, { radius: r, blur, gradient: { 0.0:'rgba(0,0,0,0)', 1.0:'#2166ac' } });
          const hotLayer  = L.heatLayer(hot,  { radius: r, blur, gradient: { 0.0:'rgba(0,0,0,0)', 1.0:'#b2182b' } });
          heat = L.layerGroup([coldLayer, hotLayer]).addTo(map);

          // Optional markers for sampling
          markers = L.layerGroup();
          pts.slice(0, 2000).forEach(p => {
            const c = makeColor(p.v, TEMP_MIN, TEMP_MAX);
            const m = L.circleMarker([p.lat, p.lon], { radius: 3, color: c, fillColor: c, fillOpacity: 0.8, weight: 0.5 });
            m.bindPopup(`${p.v.toFixed(1)}% canopy`);
            markers.addLayer(m);
          });

          L.control.layers({}, { 'High Contrast Heatmap': heat, 'Sample Markers': markers }, { collapsed: false }).addTo(map);

          const bounds = L.latLngBounds(ll);
          if (bounds.isValid()) map.fitBounds(bounds.pad(0.05));

          map.on('zoomend', () => {
            const nr = rad(map.getZoom());
            coldLayer.setOptions({ radius: nr });
            hotLayer.setOptions({ radius: nr });
          });
        })
        .catch(err => {
          console.error(err);
          alert('Failed to load canopy CSV data.');
        });
    }

    document.getElementById('apply').addEventListener('click', loadData);
    loadData();
  </script>
</body>
</html>
